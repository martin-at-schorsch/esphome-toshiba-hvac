esphome:
  name: esp32-pasco2-lambda
  friendly_name: esp32_pasco2-lambda

esp32:
  board: esp32dev
  framework:
    type: arduino

# Enable logging
logger:

# Enable Home Assistant API
api:
  encryption:
    key: "3FFuFUDhPctlWl7RUQ3HNBVH/3xDe6IgnjPJ7LByA9w="

ota:
  - platform: esphome
    password: "33929d28174b0b7f101b2bdaeedf6782"

wifi:
  ssid: !secret wifi_ssid
  password: !secret wifi_password

  # Enable fallback hotspot (captive portal) in case wifi connection fails
  ap:
    ssid: "Esp32-Pasco2-Lambda"
    password: "sZfzqj2ZjDoY"

captive_portal:


# I2C Bus Konfiguration
i2c:
  sda: 21 # GPIO Pin für SDA
  scl: 22 # GPIO Pin für SCL
  scan: true # Sucht beim Start nach I2C Geräten (nützlich für Debugging)
  frequency: 100kHz # PAS CO2 unterstützt bis zu 400kHz, 100kHz ist ein sicherer Standard


# Globale Variablen und C++ Lambda-Funktionen
globals:
  - id: pas_co2_i2c_address
    type: uint8_t
    initial_value: '0x28' # Standard I2C Adresse des PAS CO2 Sensors
  - id: pas_co2_sensor_initialized
    type: bool
    initial_value: 'false'
  - id: pas_co2_measurement_interval_s # Dieses Global wird von der C++ Initialisierungslogik verwendet
    type: uint16_t
    initial_value: '10' # Standard Messintervall in Sekunden
  - id: pas_co2_device_ptr # Zeiger auf das I2CDevice Objekt
    type: i2c::I2CDevice*
    initial_value: 'nullptr'
  - id: TAG_PAS_CO2
    type: const char*
    initial_value: '"pas_co2_lambda"'

  # Hilfsfunktionen als std::function Objekte
  - id: pas_co2_read_register_func
    type: std::function<bool(i2c::I2CDevice*, uint8_t, uint8_t*, size_t)>
    initial_value: |
      [](i2c::I2CDevice* device, uint8_t reg_addr, uint8_t *data, size_t len) -> bool {
        if (device == nullptr) return false;
        return device->read_register(reg_addr, data, len) == i2c::ERROR_OK;
      }
  - id: pas_co2_write_register_func
    type: std::function<bool(i2c::I2CDevice*, uint8_t, uint8_t*, size_t)>
    initial_value: |
      [](i2c::I2CDevice* device, uint8_t reg_addr, uint8_t *data, size_t len) -> bool {
        if (device == nullptr) return false;
        return device->write_register(reg_addr, data, len) == i2c::ERROR_OK;
      }
  - id: pas_co2_write_byte_func
    type: std::function<bool(i2c::I2CDevice*, uint8_t, uint8_t)>
    initial_value: |
      [](i2c::I2CDevice* device, uint8_t reg_addr, uint8_t value) -> bool {
        if (device == nullptr) return false;
        return device->write_byte(reg_addr, value) == i2c::ERROR_OK;
      }
  - id: pas_co2_set_operation_mode_func
    type: std::function<bool(i2c::I2CDevice*, uint8_t)>
    initial_value: |
      [](i2c::I2CDevice* device, uint8_t mode_val) -> bool {
        if (device == nullptr) return false;
        uint8_t current_meas_cfg;
        if (!id(pas_co2_read_register_func)(device, 0x04 /*PASCO2_REG_MEAS_CFG*/, &current_meas_cfg, 1)) {
          ESP_LOGE(id(TAG_PAS_CO2), "Fehler beim Lesen von MEAS_CFG zum Setzen des Modus."); // Korrigiert: .c_str() entfernt
          return false;
        }
        uint8_t new_meas_cfg = (current_meas_cfg & ~0x03 /*MEAS_CFG_OP_MODE_MASK*/) | mode_val;
        ESP_LOGD(id(TAG_PAS_CO2), "Setze MEAS_CFG auf 0x%02X (Modus: 0x%02X)", new_meas_cfg, mode_val); // Korrigiert: .c_str() entfernt
        return id(pas_co2_write_byte_func)(device, 0x04 /*PASCO2_REG_MEAS_CFG*/, new_meas_cfg);
      }
  - id: pas_co2_do_initialize_sensor_func
    type: std::function<bool(i2c::I2CDevice*, uint16_t)>
    initial_value: |
      [](i2c::I2CDevice* device, uint16_t meas_interval_s) -> bool {
        if (device == nullptr) {
            ESP_LOGE(id(TAG_PAS_CO2), "I2C-Gerät ist null bei Initialisierungsversuch."); // Korrigiert
            return false;
        }
        ESP_LOGCONFIG(id(TAG_PAS_CO2), "Initialisiere PAS CO2 Sensor (I2C @ 0x%02X)...", device->get_i2c_address()); // Korrigiert

        // extern i2c::I2CBus* i2c_bus; // ESPHome stellt i2c_bus oft global zur Verfügung
        // Alternativ: auto* i2c_bus_ptr = App.get_i2c_bus(); // Für den Standard-Bus
        // Prüfen, ob der Bus direkt verfügbar ist oder über App geholt werden muss.
        // Der Fehler 'i2c_bus is not a member of esphome::i2c' deutet darauf hin, dass es nicht so einfach ist.
        // ESPHome stellt `i2c_bus` als globalen Zeiger zur Verfügung, wenn die i2c Komponente verwendet wird.
        if (i2c_bus == nullptr) { // Prüfen, ob der globale i2c_bus Zeiger gültig ist
            ESP_LOGE(id(TAG_PAS_CO2), "Globaler I2C Bus (i2c_bus) nicht initialisiert/gefunden.");
            return false;
        }

        if (!i2c_bus->probe_device(device->get_i2c_address())) { // Korrigiert: i2c_bus direkt verwenden und get_i2c_address
             ESP_LOGE(id(TAG_PAS_CO2), "I2C Gerät nicht unter 0x%02X gefunden.", device->get_i2c_address()); // Korrigiert
             return false;
        }

        ESP_LOGD(id(TAG_PAS_CO2), "Warte bis Sensor bereit ist (SENS_RDY)..."); // Korrigiert
        uint8_t sens_status_val;
        int retries = 60;
        bool sensor_physically_ready = false;
        while (retries-- > 0) {
          if (id(pas_co2_read_register_func)(device, 0x01 /*PASCO2_REG_SENS_STS*/, &sens_status_val, 1) && (sens_status_val & 0x80 /*SENS_STS_SENS_RDY_MASK*/)) {
            sensor_physically_ready = true;
            ESP_LOGI(id(TAG_PAS_CO2), "Sensor SENS_RDY Bit ist gesetzt. Status: 0x%02X", sens_status_val); // Korrigiert
            break;
          }
          ESP_LOGD(id(TAG_PAS_CO2), "Sensor noch nicht bereit (SENS_RDY). Status: 0x%02X. Versuche: %d", sens_status_val, retries); // Korrigiert
          delay(1000);
        }
        if (!sensor_physically_ready) {
          ESP_LOGE(id(TAG_PAS_CO2), "Sensor SENS_RDY Bit wurde nicht gesetzt."); // Korrigiert
          return false;
        }

        ESP_LOGD(id(TAG_PAS_CO2), "Führe Soft-Reset durch..."); // Korrigiert
        if (!id(pas_co2_write_byte_func)(device, 0x10 /*PASCO2_REG_SENS_RST*/, 0xA3 /*SOFT_RESET_CMD*/)) {
          ESP_LOGE(id(TAG_PAS_CO2), "Fehler beim Senden des Soft-Reset Befehls."); // Korrigiert
          return false;
        }
        delay(800);

        ESP_LOGD(id(TAG_PAS_CO2), "Prüfe SENS_RDY erneut nach Reset..."); // Korrigiert
        retries = 15; 
        sensor_physically_ready = false;
        while (retries-- > 0) {
          if (id(pas_co2_read_register_func)(device, 0x01 /*PASCO2_REG_SENS_STS*/, &sens_status_val, 1) && (sens_status_val & 0x80 /*SENS_STS_SENS_RDY_MASK*/)) {
            sensor_physically_ready = true;
            ESP_LOGI(id(TAG_PAS_CO2), "Sensor SENS_RDY ist nach Reset gesetzt. Status: 0x%02X", sens_status_val); // Korrigiert
            break;
          }
          ESP_LOGD(id(TAG_PAS_CO2), "Sensor nicht SENS_RDY nach Reset. Status: 0x%02X. Versuche: %d", sens_status_val, retries); // Korrigiert
          delay(1000);
        }
        if (!sensor_physically_ready) {
          ESP_LOGE(id(TAG_PAS_CO2), "Sensor SENS_RDY wurde nach Reset nicht gesetzt."); // Korrigiert
          return false;
        }
        
        ESP_LOGD(id(TAG_PAS_CO2), "Setze Messperiode auf %u Sekunden...", meas_interval_s); // Korrigiert
        uint8_t meas_rate_data[2];
        meas_rate_data[0] = (meas_interval_s >> 8) & 0xFF;
        meas_rate_data[1] = meas_interval_s & 0xFF;
        if (!id(pas_co2_write_register_func)(device, 0x02 /*PASCO2_REG_MEAS_RATE_H*/, meas_rate_data, 2)) {
           ESP_LOGE(id(TAG_PAS_CO2), "Fehler beim Setzen der Messrate."); // Korrigiert
           return false;
        }
        delay(50);

        ESP_LOGD(id(TAG_PAS_CO2), "Setze Operationsmodus auf Idle..."); // Korrigiert
        if (!id(pas_co2_set_operation_mode_func)(device, 0x00 /*OP_MODE_IDLE*/)) return false;
        delay(50);

        ESP_LOGD(id(TAG_PAS_CO2), "Setze Operationsmodus auf kontinuierlich..."); // Korrigiert
        if (!id(pas_co2_set_operation_mode_func)(device, 0x02 /*OP_MODE_CONTINUOUS*/)) return false;
        delay(50);

        ESP_LOGCONFIG(id(TAG_PAS_CO2), "PAS CO2 Sensor Initialisierung abgeschlossen."); // Korrigiert
        return true;
      }
  - id: pas_co2_read_co2_value_func
    type: std::function<optional<float>(i2c::I2CDevice*)>
    initial_value: |
      [](i2c::I2CDevice* device) -> optional<float> {
        if (device == nullptr || !id(pas_co2_sensor_initialized)) { // Korrigiert: .state entfernt
          return {};
        }
        
        uint8_t meas_status_val;
        if (!id(pas_co2_read_register_func)(device, 0x07 /*PASCO2_REG_MEAS_STS*/, &meas_status_val, 1)) {
          ESP_LOGW(id(TAG_PAS_CO2), "Fehler beim Lesen des Messstatus (MEAS_STS)."); // Korrigiert
          return {};
        }
        ESP_LOGV(id(TAG_PAS_CO2), "Messstatus (MEAS_STS): 0x%02X", meas_status_val); // Korrigiert

        if (meas_status_val & 0x10 /*MEAS_STS_DATA_RDY_MASK*/) {
          uint8_t co2_data_buf[2];
          if (id(pas_co2_read_register_func)(device, 0x05 /*PASCO2_REG_CO2PPM_H*/, co2_data_buf, 2)) {
            uint16_t co2_ppm = (co2_data_buf[0] << 8) | co2_data_buf[1];
            ESP_LOGD(id(TAG_PAS_CO2), "CO2 gelesen: %u ppm", co2_ppm); // Korrigiert
            return (float)co2_ppm;
          } else {
            ESP_LOGW(id(TAG_PAS_CO2), "Fehler beim Lesen der CO2 Datenregister."); // Korrigiert
            return {};
          }
        } else {
          ESP_LOGD(id(TAG_PAS_CO2), "Daten noch nicht bereit (MEAS_STS DATA_RDY Bit nicht gesetzt)."); // Korrigiert
          return {};
        }
      }
  - id: pas_co2_read_product_info_func
    type: std::function<optional<std::pair<uint8_t, uint8_t>>(i2c::I2CDevice*)>
    initial_value: |
      [](i2c::I2CDevice* device) -> optional<std::pair<uint8_t, uint8_t>> {
        if (device == nullptr) return {};
        uint8_t prod_rev_id_val;
        if (id(pas_co2_read_register_func)(device, 0x00 /*PASCO2_REG_PROD_ID*/, &prod_rev_id_val, 1)) {
          uint8_t product_id = (prod_rev_id_val & 0xE0) >> 5;
          uint8_t revision_id = prod_rev_id_val & 0x1F;
          return std::make_pair(product_id, revision_id);
        }
        ESP_LOGW(id(TAG_PAS_CO2), "Fehler beim Lesen des Produkt/Revision ID Registers."); // Korrigiert
        return {};
      }

sensor:
  - platform: template 
    id: pas_co2_value 
    name: "PAS CO2 Konzentration Lambda"
    unit_of_measurement: "ppm"
    icon: "mdi:molecule-co2"
    accuracy_decimals: 0
    update_interval: 10s 
    lambda: |-
      // Lokale #define Direktiven (Wiederholung notwendig ohne include Datei)
      #define PASCO2_REG_PROD_ID 0x00
      #define PASCO2_REG_SENS_STS 0x01
      #define PASCO2_REG_MEAS_RATE_H 0x02
      #define PASCO2_REG_MEAS_CFG 0x04
      #define PASCO2_REG_CO2PPM_H 0x05
      #define PASCO2_REG_MEAS_STS 0x07
      #define PASCO2_REG_SENS_RST 0x10
      #define SENS_STS_SENS_RDY_MASK 0x80
      #define MEAS_CFG_OP_MODE_MASK 0x03
      #define MEAS_STS_DATA_RDY_MASK 0x10
      #define OP_MODE_IDLE 0x00
      #define OP_MODE_CONTINUOUS 0x02
      #define SOFT_RESET_CMD 0xA3

      // I2CDevice Objekt erstellen, falls noch nicht geschehen
      if (id(pas_co2_device_ptr) == nullptr) {
        // extern i2c::I2CBus* i2c_bus; // ESPHome stellt i2c_bus oft global zur Verfügung
        if (i2c_bus == nullptr) { // Prüfen, ob der globale i2c_bus Zeiger gültig ist
             ESP_LOGE(id(TAG_PAS_CO2), "Globaler I2C Bus (i2c_bus) im Sensor-Lambda nicht gefunden!"); // Korrigiert
             return {};
        }
        id(pas_co2_device_ptr) = new i2c::I2CDevice(i2c_bus, id(pas_co2_i2c_address)); // Korrigiert: .state entfernt
        ESP_LOGD(id(TAG_PAS_CO2), "PAS CO2 I2CDevice Objekt erstellt für Adresse 0x%02X.", id(pas_co2_i2c_address)); // Korrigiert
      }

      // Sensor initialisieren, falls noch nicht geschehen
      if (!id(pas_co2_sensor_initialized)) { // Korrigiert: .state entfernt
        ESP_LOGI(id(TAG_PAS_CO2), "Führe einmalige Sensorinitialisierung durch..."); // Korrigiert
        if (id(pas_co2_do_initialize_sensor_func)(id(pas_co2_device_ptr), id(pas_co2_measurement_interval_s))) { // Korrigiert: .state entfernt
          id(pas_co2_sensor_initialized) = true;
          ESP_LOGI(id(TAG_PAS_CO2), "Sensorinitialisierung erfolgreich."); // Korrigiert
        } else {
          ESP_LOGE(id(TAG_PAS_CO2), "Sensorinitialisierung fehlgeschlagen."); // Korrigiert
          return {NAN}; 
        }
      }

      // CO2-Wert lesen, wenn initialisiert
      if (id(pas_co2_sensor_initialized)) { // Korrigiert: .state entfernt
        auto co2_val = id(pas_co2_read_co2_value_func)(id(pas_co2_device_ptr));
        if (co2_val.has_value()) {
          return {co2_val.value()};
        } else {
          return {}; 
        }
      } else {
        return {NAN}; 
      }

text_sensor:
  - platform: template 
    name: "PAS CO2 Produkt ID Lambda"
    icon: "mdi:chip"
    entity_category: "diagnostic"
    update_interval: 300s 
    lambda: |-
      if (id(pas_co2_device_ptr) == nullptr) {
         ESP_LOGW(id(TAG_PAS_CO2), "Prod ID: I2C Gerät noch nicht vom Hauptsensor initialisiert."); // Korrigiert
         // extern i2c::I2CBus* i2c_bus;
         if (i2c_bus == nullptr) {
            ESP_LOGE(id(TAG_PAS_CO2), "Globaler I2C Bus (i2c_bus) im TextSensor-Lambda nicht gefunden!"); // Korrigiert
            return {"I2C Bus Fehler"};
         }
         id(pas_co2_device_ptr) = new i2c::I2CDevice(i2c_bus, id(pas_co2_i2c_address)); // Korrigiert
      }
      
      if (!id(pas_co2_sensor_initialized)) { // Korrigiert
          ESP_LOGW(id(TAG_PAS_CO2), "Prod ID: Sensor nicht initialisiert. Versuch trotzdem zu lesen."); // Korrigiert
      }

      auto prod_info = id(pas_co2_read_product_info_func)(id(pas_co2_device_ptr));
      if (prod_info.has_value()) {
        char buffer[25];
        snprintf(buffer, sizeof(buffer), "ID: %d (0x%02X)", prod_info.value().first, prod_info.value().first);
        return {std::string(buffer)};
      }
      return {"Fehler Lesen Prod ID"};

  - platform: template 
    name: "PAS CO2 Revision ID Lambda"
    icon: "mdi:chip"
    entity_category: "diagnostic"
    update_interval: 300s
    lambda: |-
      if (id(pas_co2_device_ptr) == nullptr) {
         ESP_LOGW(id(TAG_PAS_CO2), "Rev ID: I2C Gerät noch nicht vom Hauptsensor initialisiert."); // Korrigiert
         // extern i2c::I2CBus* i2c_bus;
          if (i2c_bus == nullptr) {
            ESP_LOGE(id(TAG_PAS_CO2), "Globaler I2C Bus (i2c_bus) im TextSensor-Lambda nicht gefunden!"); // Korrigiert
            return {"I2C Bus Fehler"};
         }
         id(pas_co2_device_ptr) = new i2c::I2CDevice(i2c_bus, id(pas_co2_i2c_address)); // Korrigiert
      }

       if (!id(pas_co2_sensor_initialized)) { // Korrigiert
          ESP_LOGW(id(TAG_PAS_CO2), "Rev ID: Sensor nicht initialisiert. Versuch trotzdem zu lesen."); // Korrigiert
      }

      auto prod_info = id(pas_co2_read_product_info_func)(id(pas_co2_device_ptr));
      if (prod_info.has_value()) {
        char buffer[25];
        snprintf(buffer, sizeof(buffer), "Rev: %d (0x%02X)", prod_info.value().second, prod_info.value().second);
        return {std::string(buffer)};
      }
      return {"Fehler Lesen Rev ID"};
